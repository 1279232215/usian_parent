2020-06-01
    1、redis缓存首页大广告
    2、缓存同步
    3、ElasticSearch介绍
        3.1、索引结构
        3.2、倒排索引
    4、ElasticSearch的安装
        4.1、环境的需求
        4.2、安装ES
        4.3、配置文件
        4.4、启动ES
        4.5、测试
    5、Kibana的介绍
    6、安装Kibana
    7、head的介绍
    8、安装head
    9、ES入门
        9.1、index的管理  创建  删除  修改
        9.2、mapping的管理  创建  查询  更新  删除
        9.3、document的管理  创建 post  put  查询  删除
    10、ES的读写原理
2020-06-02
    1、IK分词器
        1.1、两种模式  ik_smart   ik_max_word
        1.2、自定义词库
    2、field的详细介绍   就是怎么指定field的属性
        2.1、field的属性  type  analyzer   index   includes  excludes
        2.2、常用的field的类型  text  keyword  date  double
    3、springboot整合ElasticSearch
        3.1、ES客户端
        3.2、搭建工程
        3.3、索引管理
            3.3.1、创建索引
            3.3.2、删除索引
2020-06-03
    1、文档的管理
        1.1、添加文档
        1.2、批量添加
        1.3、修改文本
        1.4、删除文本
    2、文档搜索
        2.1、match_all查询  全部查询
        2.2、分页查询
        2.3、match查询  单条件查询
        2.4、multi_match查询   根据一个分词  查询多个字段
        2.5、boot查询   多条件查询
        2.6、filter查询  不需要计算相关度分数
        2.7、highlight查询  高光
2020-06-04
   1、商品搜索
        1.1、创建项目
            1.1.1、usian_search_service
            1.1.2、usian_search_feign
            1.1.3、usian_search_web
        1.2、导入商品数据到索引库
2020-06-05
    1、商品搜索的功能
    2、索引同步
        2.1、商品添加后做同步逻辑
2020-06-08
    问题：商品详情的查询,放在哪合适?
        如果直接查询mysql,访问量太大mysql可能会宕机
        如果用elasticSearch是不行的，应为elasticSearch是根据参数查询出一部分信息，而我们要做的事根据参数查询出一个商品信息(从海量数据中筛选出一部分数据)
        如果直接用redis把商品的数据全部存到redis中Redis会受不了，所以在添加的时候添加失效时间
    如果全部查询
    方案一：thymeleaf页面静态化
        1、创建商品详情的thymeleaf模板
        2、创建RabbitMQ消费者，收到消息后生成静态页面（D:/detail/26774635180.html）
        3、搭建nginx服务器，返回静态页面
    方案二：redis
      a、redis缓存商品详情
         1、先查询redis，如果有直接返回
         2、再查询mysql，并把查询结果装到redis中再返回

      b、如何保证redis不满？redis中都是热点商品？
        设置商品的实现时间：86400

      c、怎么保存商品信息（数据类型）？
        ITEM_INFO:123456:BASE
        ITEM_INFO:123456:DESC
        ITEM_INFO:123456:PARAM
        1、根据商品id查询商品基本信息
            1.1先从redis中查询
        2、索引同步
            2.1、商品添加后做同步逻辑
    任务：
        1、根据商品id对商品基本信息进行查询！！！
        2、根据商品id对商品描述信息进行查询！！！
        3、根据商品id对商品规格信息进行查询！！！
        4、当商品修改或者删除删除对应itemId的redis，进行同步
        5、优化redis
            5.1.缓存穿透
              缓存空对象：
                当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间（避免控制占用更多的存储空间），
                之后再访问这个数据将会从缓存中获取，保护了后端数据源；
            5.2.缓存击穿
                1. 设置热点数据永远不过期。(但是刚上的项目没有热点数据)
                2. 加分布式锁(setnx())
2020-06-09
    1、单点登录介绍
            SO英文全称Single Sign On，单点登录。SO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统，
        例如：【百度：百度文库、百度外卖】、【淘宝：淘宝、天猫】、【优思安：门户、搜索、商品详情】。它包括可以将这次主要的登
        录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。
    2、为什么要有单点登录系统？
        集群环境下会出现要求用户多次登录的情况。
        解决方案：
        1、配置tomcat集群(500)。配置tomcat Session复制。节点数不要超过5个。
        2、可以使用Session服务器（sso系统），保存Session信息。需要模拟Session。
        session和redis的共同特点：
        1、kv形式存储
        2、过期时间
        单点登录系统是使用redis模拟Session，实现Session的统一管理。
    3、需求分析
        2.1.登录
            把用户信息装到redis(token，user)，再把token装到cookie(token_key,token)
        2.1.查询
            先从cookie中取出token，再通过token从redis中查询用户信息
    4、搭建工程
        3.1.为什么要搭建工程
        因为除了登录还有注册、退出登录等功能，模块复杂，根据分布式项目的各持其职，
        所以要单独抽出来
    5、做注册用户名和手机号不重复校验
    6、注册用户功能
        6.1.记得要加密密码，加密后写入到数据库中
    7、登录功能
        7.1、根据用户名密码登录
        7.2、登录后用token作为key,TbUser作为值存到redis中
        7.3、定义Map存入token、userid、username返回前台
    8、根据token查看用户功能
    9、退出登录
        9.1、根据token删除user
2020-06-10
    1、购物车分析
        1.1.购物车功能
            1. 添加购物车商品
            2. 展示购物车列表页面
            3. 修改购物车商品数量
            4. 删除购物车商品
    2、购物车设计
        2.1. 用户未登录状态下：在不登陆的情况下把购物车信息写入cookie
           	优点：
           		1、不占用服务端存储空间
           		2、代码实现简单。
           		3、用户体验好
           	缺点：
           		1、cookie中保存的容量有限。最大4k
           		2、把购物车信息保存在cookie中，更换设备购物车信息不能同步。
        2.2. 用户已登录状态下：把购物车信息保存到服务端的 Redis 中
           	优点：
           		1、更换设备购物车信息可以同步
           	缺点：
           		1、占用服务端存储空间
    3、创建工程
        usian_cart_service,usian_cart_feign,usian_cart_web

    4、未登录状态操作购物车
        4.1.业务逻辑：
            1、从cookie中查询商品列表：Map<itemId,TbItem> 商品购买数量使用TbItem的num保存
            	    购物车已存在则直接返回
                    购物车不存在则创建空的购物车并返回
            2、添加商品到购物车：
            	如果购物车存在该商品，商品数量相加。
            	如果购物车不存在该商品，根据商品id查询商品信息并添加到购车列表
            3、把购车商品列表写入cookie。
            	读写cookie可以使用CookieUtils工具类实现
            4、查看列表
                根据传过来的userId获取到map,然后遍历创建list进行存储返回
            5、修改商品数量
                根据传过来的num和itemId先获取到map,根据itemId查对应的value，然后赋值num,重新写到cookie
            6、删除商品
                根据传过来的itemId,获取到map.remove(itemId)重新赋值到cookie
    5、登录状态操作购物车
         添加商品
         1、从redis中查询商品列表：Map<itemId,TbItem> 商品购买数量使用TbItem的num保存
                  购物车已存在则直接返回
                  购物车不存在则创建空的购物车并返回
         2、添加商品到购物车：
                  如果购物车存在该商品，商品数量相加。
                  如果购物车不存在该商品，根据商品id查询商品信息并添加到购车列表
         3、把购车商品列表写入redis。
         4、查看列表
                  根据传过来的userId获取到map,然后遍历创建list进行存储返回
         5、修改商品数量
                  根据传过来的num和itemId先获取到map,根据itemId查对应的value，然后赋值num,重新写到redis
         6、删除商品
                  据传过来的itemId,获取到map.remove(itemId)重新赋值到redis
    6、cookie同步到redis中
        1、先从cookie中查询出数据
        2、再从登录返回中的map获取userId，根据id查询出redis中购物车的信息
        3、遍历cookieMap中所有的key,cookieMap和redisMap根据key获取到tbItem
        4、看redisMap是否能根据cookieMap遍历的key获取到数据，如果能则添加数量，不能则向redisMap中添加新值
        5、去覆盖redis中的map
        6、删除cookie中的数据
2020-06-10
    订单分析
      订单功能
    1、在购物车页面点击“去结算”按钮跳转到订单确认页面
    	a) 展示商品列表
    	b) 配送地址列表
        c) 选择支付方式
    2、订单确认页面需要根据用户查询配送地址，展示订单确认页面之前，应该确认用户身份
    	a) 如果用户未登录或登录过期跳转到登录页面
    	d) 登录成功后再跳转到订单确认页面
    3、提交订单
    	a) 生成订单
    4、扣减库存
    5、关闭超时订单
    	a) 定时扫描超时2天未付款的订单，并关闭订单
    	b) 加回库存
    6、新建工程: usian-order-service,usian-order-web,usian-order-feign
    7、用户身份认证
        1、使用springmvc的拦截器拦截所有订单的请求
        2、业务逻辑
           a) 从cookie中取token。
           b) 根据token调用sso服务查询用户信息。
           d) 如果查不到用户信息则跳转到登录页面。
           e) 查询到用户信息放行。
    8、用户登录后点击去结算，展示结算数据
        8.1根据传过来的userId去获取redis中存的map
        8.2创建list，然后遍历商品ids,根据遍历的id获取redisCar中的数据，存到list中进行返回





